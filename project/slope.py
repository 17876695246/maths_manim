from manim import *
import numpy as np

class slope(Scene):
    def construct(self):
        t_directory = Text('目录', font_size = 50)
        t_directory.to_edge(UP, buff = 0.6)
        t1_directory = Text('1. 斜率(上)', font_size = 30,)
        t1_directory.to_edge(LEFT, buff = 0.5)
        t2_directory = Text('2. 导数(上)', font_size = 30)
        t3_directory = Text('3. 定积分(下)', font_size = 30)
        t3_directory.to_edge(RIGHT, buff = 0.5)
        self.play(
            Write(t_directory), 
            Write(t1_directory),
            Write(t2_directory),
            Write(t3_directory),
            run_time = 1
        )
        self.wait(1.5)
        self.play(FadeOut(t_directory,t1_directory,t2_directory,t3_directory))
        t4_directory = Text('1. 斜率(上)', font_size = 30,)
        self.play(Write(t4_directory),t4_directory.animate.scale(1.5),run_time = 1)
        self.wait(1)
        self.play(FadeOut(t4_directory))
        self.wait(0.5)
        t = Text('从初中阶段开始，我们学习了一次函数', font_size = 25)
        t.to_edge(DOWN, buff = 0.6)
        self.play(Write(t), run_time = 1.5)
        self.wait(2)
        t1 = Text('他的表达式很简单，为y=kx+b', font_size = 25)
        t1.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t,t1), run_time = 1.5)
        self.wait(2)
        axes1 = Axes(
            x_range=[0,6,1],
            y_range=[0,6,1],
            x_length=5,
            y_length=5
        ).to_edge(DOWN, buff=2).to_edge(LEFT,buff=0.6).add_coordinates().set_color(WHITE)
        func1 = axes1.plot(lambda x : x ** 1, x_range=[0,5],color=WHITE)
        func1_text1 = MathTex("y=x").next_to(UP*2.28+LEFT*2)
        self.play(Create(axes1),run_time=1.5)
        self.play(Create(func1),run_time=1)
        self.play(Create(func1_text1),run_time=1)
        self.wait(0.5)
        t2 = Text('显然的，若我们任取两点并记录坐标', font_size = 25)
        t2.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t1,t2), run_time = 1.5)
        self.wait(2)
        dot1 = Dot(axes1.c2p(2,2),color=WHITE)
        dot2 = Dot(axes1.c2p(4,4),color=WHITE)
        self.play(Create(dot1),run_time=0.5)
        self.play(Create(dot2),run_time=0.5)
        dot1_text1 = MathTex("A").scale(0.6).next_to(dot1,RIGHT)
        dot1_text1_latex1 = Tex(r'$(x_1,y_1)$').scale(0.8).next_to(dot1_text1,RIGHT,buff=0.1)
        dot2_text1 = MathTex("B").scale(0.6).next_to(dot2,RIGHT)
        dot2_text1_latex2 = Tex(r'$(x_2,y_2)$').scale(0.8).next_to(dot2_text1,RIGHT,buff=0.1)
        self.play(Create(dot1_text1),run_time=0.25)
        self.play(Create(dot1_text1_latex1))
        self.play(Create(dot2_text1),run_time=0.25)
        self.play(Create(dot2_text1_latex2))
        t3 = Text('令A,B代入y=kx+b试试？', font_size = 25)
        t3.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t2,t3), run_time = 1.5)
        self.wait(2)
        math_latex1 = Tex(r'$\begin{cases} y_1=ax_1+b \\ y_2=ax_2+b \end{cases}$')
        math_latex1.shift(RIGHT*2)
        self.play(Write(math_latex1),run_time=0.5)
        math_latex2 = Tex(r'$y_1-y_2=k(x_1-x_2)+b-b$')
        math_latex2.shift(RIGHT*2)
        self.play(ReplacementTransform(math_latex1,math_latex2))
        self.wait(0.5)
        math_latex3 = Tex(r'$k=\frac{y_1-y_2}{x_1-x_2}$')
        math_latex2_1 = Tex(r'$y_1-y_2=k(x_1-x_2)$').shift(RIGHT*3).scale(1.2)
        self.play(ReplacementTransform(math_latex2,math_latex3))
        self.play(FadeOut(axes1,func1,func1_text1,dot1,dot1_text1,dot1_text1_latex1,dot2,dot2_text1,dot2_text1_latex2,))
        self.play(math_latex3.animate.scale(1.5).shift(LEFT*4))
        self.play(Write(math_latex2_1))
        self.wait(0.5)
        t4 = Text('于是，我们便得到了k在一次函数上两点坐标的关系式', font_size = 25)
        t4.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t3,t4), run_time = 1.5)
        self.wait(2)
        t5 = Text('显然的，我们把它称为斜率(点斜式)', font_size = 25)
        t5.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t4,t5), run_time = 1.5)
        self.wait(2)
        self.play(FadeOut(t5,math_latex3,math_latex2_1))
        t6 = Text('然而，在初中阶段关于k的讨论到斜率后便戛然而止，直到高中...', font_size = 25)
        t6.to_edge(DOWN, buff = 0.6)
        self.play(Write(t6), run_time = 1.5)
        self.wait(2)
        self.play(FadeOut(t6))
        t_directory = Text('目录', font_size = 50)
        t_directory.to_edge(UP, buff = 0.6)
        t1_directory = Text('1. 斜率(上)', font_size = 30,)
        t1_directory.to_edge(LEFT, buff = 0.5)
        t2_directory = Text('2. 导数(上)', font_size = 30)
        t3_directory = Text('3. 定积分(下)', font_size = 30)
        t3_directory.to_edge(RIGHT, buff = 0.5)
        self.play(
            Write(t_directory), 
            Write(t1_directory),
            Write(t2_directory),
            Write(t3_directory),
            run_time = 1
        )
        self.wait(1.5)
        self.play(FadeOut(t_directory,t1_directory,t2_directory,t3_directory))
        t4_directory = Text('2. 导数(上)', font_size = 30,)
        self.play(Write(t4_directory),t4_directory.animate.scale(1.5),run_time = 1)
        self.wait(1)
        self.play(FadeOut(t4_directory))
        self.wait(0.5)
        t7 = Text('那么，其他函数也有斜率吗？', font_size = 25)
        t7.to_edge(DOWN, buff = 0.6)
        self.play(Write(t7), run_time = 1.5)
        self.wait(2)
        t8 = Tex('答案是肯定的，我们作出$y=ax^{2}+bx+c$的函数图试试？', font_size = 25)
        t8.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t7,t8), run_time = 1.5)
        self.wait(2)
        axes2 = Axes(
            x_range=[0,6,1],
            y_range=[0,6,1],
            x_length=6,
            y_length=6
        ).to_edge(DOWN, buff=1.5).to_edge(LEFT,buff=0.6).add_coordinates().set_color(WHITE)
        func2 = axes2.plot(lambda x : 0.3*x ** 2, x_range=[0,4],color=WHITE)
        func2_text1 = Tex(r'$f(x)=0.3x^{2}$').shift(UP*3+LEFT*4)
        self.play(Create(axes2),run_time=1.5)
        self.play(Create(func2),run_time=1)
        self.play(Create(func2_text1),run_time=1)
        t9 = Text('显然的，若我们任取两点并相连', font_size = 25)
        t9.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t8,t9), run_time = 1.5)
        self.wait(2)
        dot3 = Dot(axes2.c2p(1,0.3),color=WHITE)
        dot4 = Dot(axes2.c2p(3,2.7),color=WHITE)
        line1 = Line(dot3.get_center(),dot4.get_center(),color=WHITE)
        self.play(Create(dot3),Create(dot4),Create(line1),run_time = 1)
        t10 = Text('那么这两点就会形成一条直线', font_size = 25)
        t10.to_edge(UP, buff = 0.3)
        t10_line = Line(t10.get_left(),t10.get_right())
        t10_dot1 = Dot(t10.get_left())
        self.play(Create(t10_line),Write(t10),run_time=1)
        t11 = Text('相信都看出来了，这也不像这个函数的曲线()', font_size = 25)
        t11.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t9,t11), run_time = 1.5)
        self.wait(2)
        self.play(Transform(t10,t10_dot1),Transform(t10_line,t10_dot1),run_time=1)
        t12 = Text('所以让我们把它点的位置缩小', font_size = 25)
        t12.to_edge(DOWN, buff = 0.6)
        self.play(FadeOut(t10,t10_line,t10_dot1,t10_dot1))
        self.play(ReplacementTransform(t11,t12), run_time = 1.5)
        dot5 = Dot()
        dot5_update1 = ValueTracker(3.0)
        def dot_updater(mob):
            dot5_update1_value = dot5_update1.get_value()
            mob.move_to(axes2.c2p(dot5_update1_value,0.3*dot5_update1_value**2,0))
        self.add(dot5)
        dot5.add_updater(dot_updater)
        line2 = Line(color= YELLOW)
        line2_update1 = ValueTracker(3.0)
        def line_updater(line):
            line2_update1_value = line2_update1.get_value()
            line.put_start_and_end_on(axes2.c2p(1,0.3,0),axes2.c2p(line2_update1_value,0.3*line2_update1_value**2,0))
        self.add(line2)
        line2.add_updater(line_updater)
        self.play(FadeOut(dot4,line1))
        self.play(dot5_update1.animate.set_value(1.4),line2_update1.animate.set_value(1.4),run_time=1)
        t13 = Text('显然的，当两点越来越近时，我们的斜线也越来越相似', font_size = 25)
        t13.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t12,t13), run_time = 1.5)
        self.wait(2)
        t14 = Text('所以让我们先把这个斜线拿出来', font_size = 25)
        t14.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t13,t14), run_time = 1.5)
        self.play(FadeOut(line2))
        Triangle1_p1 = np.array(axes2.c2p(4,2,0))
        Triangle1_p2 = np.array(axes2.c2p(5,2,0))
        Triangle1_p3 = np.array(axes2.c2p(5,3,0))
        Triangle1 = Polygon(Triangle1_p1,Triangle1_p2,Triangle1_p3,color= YELLOW)
        self.play(Create(Triangle1))
        self.wait(0.5)
        t15 = Tex(r'不难发现，其中三角形的高为$y_2-y_1$，底为$x_2-x_1$,那么导数的几何意义就是函数的切线', font_size = 25)
        t15.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t14,t15), run_time = 1.5)
        Triangle1_location1 = Brace(Triangle1, DOWN)
        Triangle1_location1_text1 = Triangle1_location1.get_tex("x_2-x_1")
        Triangle1_location2 = Brace(Triangle1, RIGHT)
        Triangle1_location2_text1 = Triangle1_location2.get_tex("y_2-y_1")
        self.add(Triangle1_location1_text1,Triangle1_location2_text1)
        self.play(Create(Triangle1_location1),Create(Triangle1_location2),run_time = 1)
        self.wait(2)
        self.play(FadeOut(Triangle1_location1),FadeOut(Triangle1_location2),FadeOut(Triangle1_location1_text1),FadeOut(Triangle1_location2_text1),FadeOut(Triangle1),FadeOut(axes2),FadeOut(func2),FadeOut(func2_text1),FadeOut(dot3),FadeOut(dot4),FadeOut(dot5),run_time = 1.5)
        t16 = Tex(r'我们令$\Delta x=x_2-x_1$,令$\Delta y=y_2-y_1$', font_size = 25)
        t16.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t15,t16), run_time = 1.5)
        self.wait(2)
        t17 = Text('于是我们便能得到', font_size = 25)
        t17.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t16,t17), run_time = 1.5)
        t18 = Tex(r'$k=\frac{\Delta y}{\Delta x} = \frac{f(x_2)-f(x_1)}{x_2-x_1} =\frac{y_2 - y_1}{x_2-x_1}$', font_size = 100)
        self.play(Create(t18), run_time = 1.5)
        self.wait(2)
        t19 = Tex(r'显然的，若我们令$x_0$为初始量，$\Delta x$ 为增量，则有', font_size = 25)
        t19.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t17,t19), run_time = 1.5)
        t20 = Tex(r'$k = \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}$', font_size = 100)
        self.play(ReplacementTransform(t18,t20), run_time = 1.5)
        self.wait(2)
        t21 = Tex(r'当$\Delta x$无限趋近于0时，k就越趋近于该时斜率', font_size = 25)
        t21.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t19,t21), run_time = 1.5)
        self.wait(2)
        t22 = Tex('因此，我们令 $\lim_{ \Delta x \\to 0}$ 为 $\Delta x$ 在无限趋近于0，则有', font_size = 25)
        t22.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t21,t22), run_time = 1.5)
        t23 = MathTex('k = f^{ \prime }({ x_0 }) &= \lim_{ \Delta x \\to 0 }{ {\Delta y } \over { \Delta x } } = \lim_{ \Delta x \\to 0 }{ {f(x_0 + \Delta x ) - f(x_0) } \over { \Delta x } }')
        self.play(ReplacementTransform(t20,t23), run_time = 1.5)
        self.wait(2)
        t24 = MathTex('\lim_{ \Delta x \\to 0 }{ {f(x_0 + \Delta x ) - f(x_0) } \over { \Delta x - f(x_0) } }')
        t25 = Text('那么，这又有什么用呢？',font_size = 25)
        t25.next_to(t24, DOWN, buff = 0.6)
        self.play(ReplacementTransform(t23,t24), ReplacementTransform(t22,t25), run_time = 1.5)
        self.wait(2)
        t26 = Text('不难发现，由该式可得以上内容',font_size = 25)
        t26.next_to(t25, DOWN, buff = 0.6)
        self.play(ReplacementTransform(t25,t26), run_time = 1.5)
        self.wait(2)
        self.play(FadeOut(t24,t26))
        Derivative_t1 = Tex(r'1.若f(x) =c (c为常数),则$f^{ \prime }{(x)} = 0$', font_size = 30)
        Derivative_t2 = Tex(r'2.若f(x) = $x^{a} (a \in Q )$,则$f^{ \prime }{(x)} = ax^{a-1}$', font_size = 30)
        Derivative_t3 = Tex(r'3.若f(x) = $\sin x$，则$f^{ \prime }{(x)} = \cos x$', font_size = 30)
        Derivative_t4 = Tex(r'4.若f(x) = $\cos x$，则$f^{ \prime }{(x)} = -\sin x$', font_size = 30)
        Derivative_t5 = Tex(r'5.若f(x) = $a^{x}$ ,则$f^{ \prime }{(x)} = a^{x} \ln{a}$', font_size = 30)
        Derivative_t6 = Tex('6.若$f(x) = e^{x}$，则$f^{ \prime }{(x)} = e^{x}$', font_size = 30)
        Derivative_t7 = Tex(r'7.若$f(x) = \log_{a}{x}$,则$f^{ \prime }{(x)} = \frac{1}{x \ln a}$', font_size = 30)
        Derivative_t8 = Tex(r'8.若$f(x) = \ln x$，则$f^{ \prime }{(x)} = \frac{1}{x}$', font_size = 30)
        Derivative_t9 = Tex(r'9.$[f(x)\pm g(x)]^{\prime} = f^{ \prime }{(x)} \pm g^{ \prime }{(x)}$', font_size = 30)
        Derivative_t10 = Tex(r'10.$[f(x) \cdot g(x)]^{\prime} = f^{ \prime }{(x)\cdot g(x)} + f(x) \cdot g^{ \prime }{(x)}$', font_size = 30)
        Derivative_t11 = Tex(r'11.$[\frac{f(x)}{g(x)}]^{ \prime } = \frac{f^{ \prime }{(x)} \cdot g(x) - f(x) \cdot g^{ \prime }{(x)}}{[g(x)]^{2}},(g(x) \neq 0)$', font_size = 30)
        Derivative_t12 = Tex(r'12.$[cf(x)]^{ \prime } = cf^{ \prime }{(x)}$', font_size = 30)
        Derivative_t13 = Tex(r'13.若$y=f(g(x)),y=f(u),u=g(x)$,则${y_x}^{\prime} = {y_u}^{\prime} \cdot {u_x}^{\prime}$', font_size = 30)
        Derivative_t1.to_edge(UP).to_edge(LEFT, buff = 0.5)
        Derivative_t2.next_to(Derivative_t1, DOWN, buff = 0.5)
        Derivative_t3.next_to(Derivative_t2, DOWN, buff = 0.5)
        Derivative_t4.next_to(Derivative_t3, DOWN, buff = 0.5)
        Derivative_t5.next_to(Derivative_t4, DOWN, buff = 0.5)
        Derivative_t6.next_to(Derivative_t5, DOWN, buff = 0.5)
        Derivative_t7.to_edge(UP, buff = 0.5).to_edge(RIGHT, buff = 0.5)
        Derivative_t8.next_to(Derivative_t7, DOWN, buff = 0.5)
        Derivative_t9.next_to(Derivative_t8, DOWN, buff = 0.5)
        Derivative_t10.next_to(Derivative_t9, DOWN, buff = 0.5).to_edge(RIGHT, buff = 0.5)
        Derivative_t11.next_to(Derivative_t10, DOWN, buff = 0.5)
        Derivative_t12.next_to(Derivative_t11, DOWN, buff = 0.5)
        Derivative_t13.next_to(Derivative_t12, DOWN, buff = 0.5).to_edge(RIGHT, buff = 0.8)
        self.play(
        Write(Derivative_t1),
        Write(Derivative_t2),
        Write(Derivative_t3),
        Write(Derivative_t7),
        Write(Derivative_t4),
        Write(Derivative_t5),
        Write(Derivative_t6),
        Write(Derivative_t8),
        Write(Derivative_t9),
        Write(Derivative_t10),
        Write(Derivative_t11),
        Write(Derivative_t12),
        Write(Derivative_t13),
        run_time = 2
        )
        self.wait(5)
        self.play(
            Unwrite(Derivative_t1),
            Unwrite(Derivative_t2),
            Unwrite(Derivative_t3),
            Unwrite(Derivative_t4),
            Unwrite(Derivative_t5),
            Unwrite(Derivative_t6),
            Unwrite(Derivative_t7),
            Unwrite(Derivative_t8),
            Unwrite(Derivative_t9),
            Unwrite(Derivative_t10),
            Unwrite(Derivative_t11),
            Unwrite(Derivative_t12),
            Unwrite(Derivative_t13),
            run_time = 2
        )
        t27 = Text('然而，到这里便已经结束，后文便是高考内容，本视频不再讲解',font_size = 25)
        t27.to_edge(DOWN, buff = 0.6)
        self.play(Write(t27))
        self.wait(2)
        t28 = Text('下一期，将尝试在现有的讲解上介绍定积分，我是水岷，感谢大家观看',font_size = 25)
        t28.to_edge(DOWN, buff = 0.6)
        self.play(ReplacementTransform(t27,t28),run_time = 1.5)
        self.wait(2)
        self.play(FadeOut(t28))
        t29 = Text('BGM:A State of Inertia',font_size = 25)
        t30 = Text('参考书籍：《普通高中课程标准实验教科书——数学选修2—2》', font_size = 25)
        t30.next_to(t29,DOWN)
        self.play(Create(t29),Create(t30))
        self.wait(4)
        self.play(Uncreate(t29),Uncreate(t30))
        t31 = Text('特别感谢', font_size = 25)
        t31.to_edge(UP, buff = 0.6)
        t32  = Text('manim幼儿园', font_size = 25)
        t32.next_to(t31,DOWN)
        img1 = ImageMobject("C:\\Users\\86178\\anaconda3\\envs\\Shuimin\\Lib\\site-packages\\manim\\assets\\raster_images\\乐正垂星.jpg").scale(1)
        img2 = ImageMobject("C:\\Users\\86178\\anaconda3\\envs\\Shuimin\\Lib\\site-packages\\manim\\assets\\raster_images\\一条开摆的摆线.jpg").scale(1)
        img1_text = Text('乐正垂星', font_size = 25)
        img2_text = Text('一条开摆的摆线', font_size = 25)
        img1.to_edge(LEFT, buff = 3)
        img2.to_edge(RIGHT, buff = 3)
        img1_text.next_to(img1,DOWN)
        img2_text.next_to(img2,DOWN)
        self.play(FadeIn(t31,t32,img1,img2,img1_text,img2_text))
        self.wait(4)
        self.play(FadeOut(t31,t32,img1,img2,img1_text,img2_text))
